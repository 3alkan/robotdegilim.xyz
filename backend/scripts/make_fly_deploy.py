"""
Create a clean, self-contained Fly.io deployable folder for the backend.

Outputs by default to: <repo_root>/fly-io/robotdegilim

Generated contents:
- Dockerfile (Gunicorn, port 8080, entrypoint src.app:app)
- fly.toml (http_service on 8080)
- requirements.txt (copied from backend/requirements.txt)
- .dockerignore (sane defaults)
- src/ (copied from backend/src)

Usage (from repo root or any dir):
    python backend/scripts/make_fly_deploy.py --help

Notes:
- Configure secrets on Fly with: fly secrets set ACCESS_KEY=... SECRET_ACCESS_KEY=... MAIL_USERNAME=... MAIL_PASSWORD=...
- On first deploy you might want to run: fly apps create <app-name> (or `fly launch` in the folder)
"""

from __future__ import annotations

import argparse
import os
from pathlib import Path
import shutil
import sys


RECOMMENDED_PY_VERSION = "3.12"


DOCKERFILE_TEMPLATE = """# syntax=docker/dockerfile:1

ARG PYTHON_VERSION={python_version}

FROM python:${{PYTHON_VERSION}}-slim

LABEL fly_launch_runtime="flask"

WORKDIR /code

# Install system deps (optional minimal set). Uncomment if you need build tools for some wheels.
# RUN apt-get update && apt-get install -y --no-install-recommends \
#     build-essential \
#     && rm -rf /var/lib/apt/lists/*

COPY requirements.txt requirements.txt
RUN pip3 install --no-cache-dir -r requirements.txt

# Copy only the app sources
COPY src ./src

# Pre-create runtime folders (logs/data are created at runtime too, but ensures path exists)
RUN mkdir -p storage/logs storage/data

# Include manual department prefix overrides in the image
COPY storage/data/manualPrefixes.json storage/data/manualPrefixes.json

EXPOSE 8080

# Use src.app:app where `app` is the Flask app object in backend/src/app.py
CMD ["gunicorn", "-w", "{workers}", "-b", "[::]:8080", "--timeout", "{timeout}", "src.app:app"]
"""


FLY_TOML_TEMPLATE = """# fly.toml app configuration generated by make_fly_deploy.py

app = '{app_name}'
primary_region = '{region}'

[build]

[env]
    LOG_LEVEL = "INFO"
    LOG_JSON = "false"
    APP_VERSION = "0.1.0"
    ALLOWED_ORIGINS = "*"

[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = 'off'
  auto_start_machines = false
  min_machines_running = 1
  processes = ['app']

    # Optional HTTP health check for /status
    [[http_service.checks]]
        type = "http"
        interval = "10s"
        timeout = "2s"
        grace_period = "10s"
        method = "get"
        path = "/status"

[[vm]]
  memory = '1gb'
  cpu_kind = 'shared'
  cpus = 1
"""


DOCKERIGNORE = """# Created by make_fly_deploy.py
__pycache__/
*.py[cod]
*.pyo
*.pyd
*.so
.pytest_cache/
.mypy_cache/
.venv/
venv/
.DS_Store
.git/
.gitignore
*.log
storage/logs/
# Ignore storage/data by default, except manualPrefixes.json
storage/data/**
!storage/data/
!storage/data/manualPrefixes.json
storage/data/*.tmp
tests/
"""


def copy_requirements(backend_dir: Path, target_dir: Path) -> None:
    src_req = backend_dir / "requirements.txt"
    if not src_req.exists():
        raise FileNotFoundError(f"Missing requirements.txt at {src_req}")
    shutil.copy2(src_req, target_dir / "requirements.txt")


def copy_sources(backend_dir: Path, target_dir: Path) -> None:
    src_dir = backend_dir / "src"
    if not src_dir.exists():
        raise FileNotFoundError(f"Missing backend/src at {src_dir}")
    dst_dir = target_dir / "src"
    if dst_dir.exists():
        shutil.rmtree(dst_dir)
    shutil.copytree(src_dir, dst_dir)


def write_file(path: Path, content: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8", newline="\n")


def read_file_text(path: Path) -> str:
    return path.read_text(encoding="utf-8")


def patch_dockerfile(content: str, python_version: str, *, workers: int, timeout: int) -> str:
    """Patch a provided Dockerfile to be compatible with our folder layout.

    - Ensure gunicorn target is src.app:app (project code lives under src/)
    - Prefer EXPOSE 8080 (idempotent)
    - Ensure ARG PYTHON_VERSION and FROM reference the selected version
    - If no explicit COPY for src exists, it's okay to keep COPY . . since our folder is small.
    """
    lines = content.splitlines()
    out = []
    seen_arg = False
    from_idx = -1
    for i, line in enumerate(lines):
        # Normalize the gunicorn entrypoint
        if "gunicorn" in line and "app:app" in line:
            # normalize module path
            if "src.app:app" not in line:
                line = line.replace("app:app", "src.app:app")
            # normalize workers
            line = _replace_arg_in_json_cmd(line, "-w", str(workers))
            # normalize timeout
            line = _replace_arg_in_json_cmd(line, "--timeout", str(timeout))
            # normalize bind address to IPv6 any ([::])
            line = line.replace("0.0.0.0:8080", "[::]:8080")
        # Track FROM line index
        if line.strip().startswith("FROM "):
            from_idx = len(out)
        # Normalize ARG PYTHON_VERSION
        if line.strip().startswith("ARG PYTHON_VERSION="):
            line = f"ARG PYTHON_VERSION={python_version}"
            seen_arg = True
        # Keep the rest
        out.append(line)
    content = "\n".join(out)

    # Ensure ARG PYTHON_VERSION exists near top
    if not seen_arg:
        # Insert ARG after syntax line if present, else at top
        insert_pos = 1 if (lines and lines[0].startswith("# syntax=")) else 0
        parts = content.splitlines()
        parts.insert(insert_pos, f"ARG PYTHON_VERSION={python_version}")
        content = "\n".join(parts)

    # Ensure FROM uses ${PYTHON_VERSION}-slim
    parts = content.splitlines()
    for i, ln in enumerate(parts):
        if ln.strip().startswith("FROM ") and "python:" in ln:
            parts[i] = "FROM python:${PYTHON_VERSION}-slim"
            break
    content = "\n".join(parts)

    # Ensure EXPOSE 8080 exists (avoid duplicates)
    if "EXPOSE 8080" not in content:
        content += "\n\nEXPOSE 8080\n"
    
    # Ensure the manualPrefixes.json is copied if present in build context
    if "storage/data/manualPrefixes.json" not in content:
        # Insert after mkdir -p storage lines if present; else append before EXPOSE
        anchor = "RUN mkdir -p storage/logs storage/data"
        if anchor in content:
            content = content.replace(
                anchor,
                anchor + "\n\n# Include manual department prefix overrides in the image\nCOPY storage/data/manualPrefixes.json storage/data/manualPrefixes.json",
            )
        else:
            content = content.replace(
                "EXPOSE 8080",
                "# Include manual department prefix overrides in the image\nCOPY storage/data/manualPrefixes.json storage/data/manualPrefixes.json\n\nEXPOSE 8080",
            )
    return content


def _replace_arg_in_json_cmd(line: str, flag: str, value: str) -> str:
    """Best-effort replace of a gunicorn CLI arg in a JSON-array CMD line.
    If flag exists, replace its following token; if absent, append before the app module.
    """
    if "CMD [" not in line:
        return line
    try:
        # crude parse: split by comma, strip quotes/spaces
        parts = [p.strip() for p in line.split(",")]
        # find flag index
        idx = next((i for i, p in enumerate(parts) if p.strip().strip('"') == flag), None)
        if idx is not None and idx + 1 < len(parts):
            # replace value element
            parts[idx + 1] = f' "{value}"'
        else:
            # insert before last element (app module path)
            if len(parts) >= 2:
                parts.insert(-1, f' "{flag}"')
                parts.insert(-1, f' "{value}"')
        return ",".join(parts)
    except Exception:
        return line


def patch_fly_toml(content: str, app_name: str, region: str) -> str:
    """Patch fly.toml to set app name, region, ensure internal port 8080, add [env] defaults and /status check."""
    lines = content.splitlines()
    out = []
    for line in lines:
        if line.strip().startswith("app = "):
            line = f"app = '{app_name}'"
        elif line.strip().startswith("primary_region = "):
            line = f"primary_region = '{region}'"
        elif "internal_port" in line:
            # Force 8080
            line = "  internal_port = 8080"
        out.append(line)
    content = "\n".join(out)
    # If http_service block missing, append a minimal block
    if "[http_service]" not in content:
        content += (
            "\n[http_service]\n  internal_port = 8080\n  force_https = true\n"
            "  auto_stop_machines = 'off'\n  auto_start_machines = false\n  min_machines_running = 1\n"
            "  processes = ['app']\n"
        )
    # Ensure [env] block with defaults exists
    if "\n[env]\n" not in content:
        content += (
            "\n[env]\n  LOG_LEVEL = \"INFO\"\n  LOG_JSON = \"false\"\n  APP_VERSION = \"0.1.0\"\n  ALLOWED_ORIGINS = \"*\"\n"
        )
    # Ensure an HTTP /status check exists; try adding under [http_service]
    if "/status" not in content and "http_service" in content:
        content = content.replace(
            "[http_service]",
            (
                "[http_service]\n  [[http_service.checks]]\n    type = \"http\"\n    interval = \"10s\"\n"
                "    timeout = \"2s\"\n    grace_period = \"10s\"\n    method = \"get\"\n    path = \"/status\"\n"
            ),
            1,
        )
    return content


def make_deploy(
    repo_root: Path,
    app_name: str,
    region: str,
    python_version: str,
    target: Path,
    force: bool,
    from_templates: Path | None,
    workers: int,
    timeout: int,
) -> Path:
    backend_dir = repo_root / "backend"
    if not backend_dir.exists():
        raise RuntimeError(f"Could not locate backend dir at {backend_dir}")

    if target.exists() and force:
        shutil.rmtree(target)
    target.mkdir(parents=True, exist_ok=True)

    # Copy essentials
    copy_requirements(backend_dir, target)
    copy_sources(backend_dir, target)

    # Infra files: either import from --from-templates or generate
    dockerfile_path = target / "Dockerfile"
    fly_toml_path = target / "fly.toml"

    if from_templates:
        src_docker = from_templates / "Dockerfile"
        src_fly = from_templates / "fly.toml"
        if src_docker.exists():
            content = read_file_text(src_docker)
            content = patch_dockerfile(
                content, python_version=python_version, workers=workers, timeout=timeout
            )
            write_file(dockerfile_path, content)
        else:
            write_file(
                dockerfile_path,
                DOCKERFILE_TEMPLATE.format(
                    python_version=python_version, workers=workers, timeout=timeout
                ),
            )
        if src_fly.exists():
            content = read_file_text(src_fly)
            content = patch_fly_toml(content, app_name=app_name, region=region)
            write_file(fly_toml_path, content)
        else:
            write_file(
                fly_toml_path,
                FLY_TOML_TEMPLATE.format(app_name=app_name, region=region),
            )
    else:
        write_file(
            dockerfile_path,
            DOCKERFILE_TEMPLATE.format(
                python_version=python_version, workers=workers, timeout=timeout
            ),
        )
        write_file(
            fly_toml_path,
            FLY_TOML_TEMPLATE.format(app_name=app_name, region=region),
        )
    write_file(target / ".dockerignore", DOCKERIGNORE)

    # Small README to remind how to deploy
    readme = f"""# Fly.io deploy folder

This folder was generated by `backend/scripts/make_fly_deploy.py`.

Quickstart:
1) Authenticate: fly auth login
2) (First time) Create app: fly apps create {app_name}
3) (Optional) Set secrets: fly secrets set ACCESS_KEY=... SECRET_ACCESS_KEY=... MAIL_USERNAME=... MAIL_PASSWORD=...
4) Deploy: fly deploy

Service listens on 8080 and serves Flask app `src.app:app` via Gunicorn.
"""
    write_file(target / "README.md", readme)

    return target


def parse_args(argv: list[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Build a Fly.io deployable folder for backend")
    parser.add_argument(
        "--target",
        default=None,
        help="Output folder for the deploy package (default: <repo>/fly-io/robotdegilim)",
    )
    parser.add_argument(
        "--app-name",
        default=os.environ.get("FLY_APP_NAME", "robotdegilim-xyz"),
        help="Fly app name to write in fly.toml",
    )
    parser.add_argument(
        "--region",
        default=os.environ.get("FLY_REGION", "otp"),
        help="Primary region code (e.g., otp)",
    )
    parser.add_argument(
        "--python-version",
        default=os.environ.get("PYTHON_VERSION", RECOMMENDED_PY_VERSION),
        help="Python version for the Docker image (e.g., 3.10.9)",
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Delete target dir if it already exists",
    )
    parser.add_argument(
        "--from-templates",
        default=None,
        help="Path containing Dockerfile and fly.toml from a previous deploy (they will be patched)",
    )
    parser.add_argument(
        "--gunicorn-workers",
        type=int,
        default=int(os.environ.get("GUNICORN_WORKERS", "2")),
        help="Gunicorn worker processes (default 2)",
    )
    parser.add_argument(
        "--gunicorn-timeout",
        type=int,
        default=int(os.environ.get("GUNICORN_TIMEOUT", "0")),
        help="Gunicorn timeout seconds (0 means no timeout; default 0)",
    )
    parser.add_argument(
        "--require-manual-prefixes",
        action="store_true",
        help=(
            "If set, exit with non-zero status when backend/storage/data/manualPrefixes.json is missing."
        ),
    )
    return parser.parse_args(argv)


def main(argv: list[str]) -> int:
    args = parse_args(argv)

    # Resolve repo root as two levels up from this script: backend/scripts -> repo_root
    script_path = Path(__file__).resolve()
    repo_root = script_path.parents[2]

    default_target = repo_root / "fly-io" / "robotdegilim"
    target = Path(args.target).resolve() if args.target else default_target

    from_templates = Path(args.from_templates).resolve() if args.from_templates else None

    built = make_deploy(
        repo_root=repo_root,
        app_name=args.app_name,
        region=args.region,
        python_version=args.python_version,
        target=target,
        force=args.force,
        from_templates=from_templates,
        workers=args.gunicorn_workers,
        timeout=args.gunicorn_timeout,
    )

    # Copy only storage/data/manualPrefixes.json if it exists
    src_manual = repo_root / "backend" / "storage" / "data" / "manualPrefixes.json"
    dst_manual = built / "storage" / "data" / "manualPrefixes.json"
    if src_manual.exists():
        dst_manual.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy2(src_manual, dst_manual)
        # Ensure .dockerignore allows it (already configured by template above)
    else:
        msg = (
            "WARNING: backend/storage/data/manualPrefixes.json not found. "
            "The image will not contain manual prefix overrides unless you add it before building/deploying."
        )
        print(msg)
        if args.require_manual_prefixes:
            print("ERROR: --require-manual-prefixes was set; aborting.")
            return 2

    # Secondary check: if the file wasn't copied for any reason, warn
    if not dst_manual.exists():
        print(
            "WARNING: Deploy folder missing storage/data/manualPrefixes.json. Ensure your .dockerignore allows it and run deploy from this folder."
        )

    rel = os.path.relpath(built, repo_root)
    print(f"Fly deploy folder created: {built} (repo-relative: {rel})")
    print("Next steps:")
    print(f"  1) cd {built}")
    print("  2) fly auth login (if needed)")
    print(f"  3) fly apps create {args.app_name} (first time)")
    print("  4) fly secrets set ACCESS_KEY=... SECRET_ACCESS_KEY=... MAIL_USERNAME=... MAIL_PASSWORD=...")
    print("  5) fly deploy")
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
